Плиско Стелла УИБО-12-24 

1.1. Сортировка выбором — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют  его местами с текущим элементом в массиве.
2.Работа алгоритма

•	#include <iostream> — подключение стандартной библиотеки для работы с вводом и выводом.
•	void selectionSort(int arr[], int size) — функция, реализующая алгоритм сортировки выбором.
•	В main() создается пример массива, определяется его размер, выводится исходный массив, затем вызывается функция сортировки.

Временная сложность алгоритма (Big O)

•	Внешний цикл выполняется примерно n-1 раз (i от 0 до n-2).
•	Для каждого шага внутренний цикл проверяет почти n-i-1 элементов (j от i+1 до n-1).
Общая оценка — сумма операций:
[ T(n) = (n-1) + (n-2) + \dots + 1 = \frac{n(n-1)}{2} ]
По асимптотической сложностью — Big O:
[ \boxed{ O(n^2) } ]

2. 1.Сортировка обменом(пузырьком) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.

2.Работа алгоритма

•	Определение функции bubble_sort(arr):
— функция сортирует список arr «пузырьковым» методом.
•	Получение длины массива n:
— n = len(arr) — для организации циклов.
•	Внешний цикл for i in range(n):
— многократно повторяет процесс, чтобы за каждый проход «вытягивать» самые большие элементы в конец массива.
•	Инициализация флага swapped = False:
— флаг показывает, происходил ли обмен элементами в текущем прохо-де. Используется для досрочного завершения, если массив уже отсортирован.
•	Внутренний цикл for j in range(0, n - i - 1):
— сравнивает соседние элементы в отсортированной части массива, которая «рас-тёт» с каждым проходом.

Временная сложность алгоритма (Big O)

•	В худшем случае — O(n^2), когда массив отсортирован в обратном порядке и все элементы без исключения нужно поменять местами.
•	В лучшем случае — O(n), если массив уже отсортирован, так как алгоритм завершит работу после первого прохода без перестановок.
Память: O(1), сортировка происходит на месте, дополнительная память не используется.

3. 1. Сортировка вставками — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на свое место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
2.Работа алгоритма

•	Подключение библиотеки <iostream>:
Позволяет выводить данные в консоль через std::cout.
•	Функция insertionSort:
•	Начинается цикл со второго элемента (i=1), так как первый элемент уже считается отсортированным.
•	Переменная key хранит текущий элемент, который необходимо вставить в отсортированный сегмент массива слева.

•	В main():
•	Создается массив arr.
•	Определяется его длина size.

Временная сложность алгоритма (Big O)

•	Внутренние операции сравнения и сдвига элементов — примерно n раз для каждого элемента.
Общая сложность:
[ T(n) = 1 + 2 + 3 + ... + (n-1) = \frac{(n-1) \times n}{2} ]
Итог — Big O:
[ \boxed{ O(n^2) } ]

4. 1. Сортировка слиянием — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
2.Работа алгоритма

•	mergeSort — это рекурсивная функция:
•	Подмассив делится на две половины, вызывая mergeSort для каждой из них.
•	merge:
•	Создает два временных массива L и R, в которые копирует элементы левой и правой части подмассива.
•	main():
•	Создает массив, выводит его, вызывает mergeSort и выводит отсортированный результат.
Временная сложность алгоритма (Big O)

На каждом уровне рекурсии массив делится пополам.
•	Количество уровней рекурсии: log2(n)
•	На каждом уровне происходит n операций по слиянию (все элементы).
•	Общее время: O(n log n)
Итог:
[ \boxed{ O(n \log n) } ]
5. 1.Сортировка Шелла – является модификацией сортировки вставками, сортирет между собой элементы, стоящие на местах, кратных определенному шагу.
2. Работа алгоритма

•	gap — интервал для сравнения элементов. 
•	Пока gap > 0:
•	Проходим по массиву, сравниваем и меняем элементы, расстояние между которыми равно gap. 
•	После каждого прохода gap делится пополам. 
•	Итоговая сортировка — вставками с большим шагом вначале, постепенно уменьшая шаг до 

Временная сложность алгоритма (Big O)

•	В худшем случае: O(n²) 
•	В среднем и лучшем случаях: зависит от выбранных интервалов, в классическом варианте — около O(n^(3/2)), но теоретическая оценка — O(n log² n). 
6. 1. Быстрая сортировка — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборре опорного элемента, разделения массива на две части  относительно опорного, и в сортировке полученных частей рекурсивным вызовом себя от них.
2.Работа алгоритма

•	Создаются три списка:
•	left для элементов меньше опорного
•	middle для элементов, равных опорному
•	right для элементов, превышающих опорный.
•	Рекурсивно сортируются left и right.
•	Итоговая отсортированная последовательность — это объединение отсортирован-ных left, middle и right.

Временная сложность алгоритма (Big O)

•	В худшем случае: O(n²) (при плохом выборе опорного элемента, например, уже отсортированном массива). 
•	В среднем и лучшем случаях: O(n log n). 
7. 1. Пирамидная сортировка – алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и момещает его в конец списка.
2.Работа алгоритма

•	buildHeap: создает кучу из массива
•	for: извлекает максимально возможный элемент (корень кучи)
•	swap: помещает его в конце массива
•	heapify: восстанавливает свойства кучи для оставшейся части
•	Повторяет последние шаги для остальной части массива

Временная сложность алгоритма (Big O)

•	Создание кучи (buildHeap) — O(n)
•	Каждый из n-1 этапов извлечения элемента и восстановления кучи — O(log n)
ИТОГ:
Время: O(n log n)
Память: O(1) (сортировка на месте).
8. 1. Последовательный поиск - простейший вид поиска заданного элементов на некотором множестве. Осуществляется путем последовательного сравнения очередного рассматриваемое значения с искомым до тех пор, пока, пока эти значения не совпадут 
2.Работа алгоритма
•	Перебираем массив (цикл for)
•	Сравниваем текущий элемент с искомым
•	Возвращаем индекс при совпадении
•	Если не нашли — возвращаем -1
•	Выводим результат в main()


Временная сложность алгоритма (Big O)

•	В худшем случае искомый элемент будет последним или его не окажется
•	Перебираются все n элементов
Время:
ИТОГ:O(n) (линейная сложность)
Память: O(1) — сортировка выполняется прямо в массиве, дополнительные структуры не требуются.
9. 1. Бинарный поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путем неоднократного деления этого множества на 2 части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества при отсутствии искомого элемента.
2.Работа алгоритма

•	Изначально устанавливаем границы поиска: left = 0, right = длина массива - 1
•	Пока границы не перекрылись (left <= right):
•	Находим середину диапазона
•	Если значение в середине равно искомому — вернуть его индекс
•	Если меньше — ищем в правой части (left = middle + 1)
•	Если больше — ищем в левой части (right = middle - 1)
•	Если проход завершился — элемента нет, возвращаем -1

Временная сложность алгоритма (Big O)

•	В худшем случае мы каждый раз делим массив пополам
•	Количество итераций — log₂ n
ИТОГ:
Время: O(log n)
Память: O(1) — поиск выполняется на месте, дополнительные переменные не нужны.
10.  1. Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
2.Работа алгоритма

•	Устанавливаем границы поиска: low = 0, high = размер массива - 1
•	Пока границы не пересеклись и target внутри диапазона arr[low..high]
•	Вычисляем предполагаемую позицию: pos ≈ low + ((high - low) / (arr[high] - arr[low])) * (target - arr[low])
•	Если arr[pos] равно target — возвращаем pos
•	Если меньше — ищем справа (low = pos + 1)
•	Если больше — ищем слева (high = pos - 1)
•	Если элемент не найден — возвращаем -1

Временная сложность алгоритма (Big O)

•	В среднем и в худшем случае, когда массив распределён равномерно O(log log n)
•	В худшем случае (например, при неравномерном распределении или очень небольшом различии между arr[high] и arr[low]) — O(n)
Память:
Время: в среднем O(log log n), в худшем случае — O(n)
ИТОГ: O(1) — используется лишь постоянное количество переменных.
11.    1. Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
3.Работа алгоритма

o	Индекс i = min(offset + fibMMm2, n-1).
o	Сравнить arr[i] с target.
o	Варианты:
	arr[i] == target → вернуть i
	arr[i] < target → смещайся вправо, обновляй числа Фибоначчи
	arr[i] > target → смещайся влево, обновляй числа Фибоначчи

Временная сложность алгоритма (Big O)

•	В худшем случае — O(log n) (так как скорость примерно удваивается за итерацию)
•	В среднем случае — примерно O(log n)
Память: O(1) — использует фиксированное количество переменных
