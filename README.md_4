Плиско Стелла УИБО-12-24 

1.  Вариант 3. Напишите рекурсивную функцию для нахождения наибольшего общего делителя (НОД) двух чисел, используя алгоритм Евклида.

Python 

3.1. Анализ алгоритма по шагам

1. Функция gcd(a, b) - находит наибольший общий делитель
2. Проверка условия - если b равно 0, возвращаем a
3. Рекурсивный вызов - иначе вызываем gcd(b, a % b)
4. Повторяем пока b не станет 0

4.1.Временная сложность: O(log(min(a, b)))

Объяснение временной сложности:

1. На каждой итерации большее число уменьшается как минимум вдвое

2. Алгоритм Евклида основан на том, что gcd(a, b) = gcd(b, a % b)

3. Число a % b всегда меньше b, и обычно значительно меньше a

4. Таким сложность логарифмическая относительно меньшего из двух чисел

С++

3.3. Анализ алгоритма по шагам:

1. Функция gcd(a, b) - принимает два числа
2. Проверка if (b == 0) - если второе число равно нулю
3. return a - возвращаем первое число (базовый случай)
4. return gcd(b, a % b) - рекурсивно вызываем с новыми числами
5. Повторяем шаги 2-4 пока b не станет 0

3.4. Временная сложность: O(log(min(a, b)))

Объяснение временной сложности:

1. На каждом шаге числа уменьшаются
2. Остаток от деления a % b всегда меньше b
3. Числа уменьшаются экспоненциально быстро
4. Количество шагов пропорционально логарифму от меньшего числа

Java

3.3. Анализ алгоритма по шагам:

1. Функция gcd(a, b) - находит наибольший общий делитель двух чисел
2. Проверка базового случая - если b равно 0, возвращаем a (так как НОД любого числа и 0 равен самому числу)
3. Рекурсивный вызов - иначе вызываем gcd(b, a % b), где a % b - это остаток от деления a на b
4. Повторяем процесс - пока второй аргумент не станет равным 0
5. Тестирование - в main методе проверяем работу функции на нескольких примерах
6. Вывод результатов - показываем НОД для каждой пары чисел

4.3. Временная сложность: O(log(min(a, b)))

Объяснение временной сложности:

1. Свойство уменьшения: На каждом шаге числа уменьшаются примерно в 2 раза
   · После двух последовательных итераций, числа уменьшаются как минимум вдвое
2. Математическое обоснование:
   · Если a ≥ b, то a mod b < a/2
   · Это означает, что за каждые 2 шага числа уменьшаются хотя бы в 2 раза
3. Количество итераций: Максимальное количество шагов пропорционально количеству цифр в меньшем числе
   · Для чисел a и b, количество шагов ≤ 5 × (количество цифр в min(a,b))
4. Логарифмическая природа: Поскольку на каждом шаге мы эффективно уменьшаем размер задачи, общее время выполнения

5.(8.)Сколько существует перестановок множества из n элементов?

Число всех возможных перестановок множества из n различных элементов равно:

n! (n-факториал)
где:
n! = n × (n-1) × (n-2) × ... × 3 × 2 × 1











